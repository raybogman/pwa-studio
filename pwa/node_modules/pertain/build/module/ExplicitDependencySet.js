import ExplicitDependency from './ExplicitDependency';
import TopologicalSorter from './TopologicalSorter';
/**
 * A set of modules that can be queried for pertaining to a given subject.
 */
export default class ExplicitDependencySet {
    constructor(resolve, names) {
        this.resolve = resolve;
        this.dependencies = [];
        this.sortedBySubject = new Map();
        names.forEach((name) => this.add(name));
    }
    /**
     * Gets a list of ExplicitDependencies in this set which pertain to the
     * subject (that is, their `package.json` has a valid key for the subject
     * that indicates a requireable file). Detects dependencies between the
     * packages that pertain and sorts the list in dependency order.
     */
    pertaining(subject) {
        let sorted = this.sortedBySubject.get(subject);
        if (!sorted) {
            const pertaining = this.dependencies.filter((dependency) => dependency.pertains(subject));
            // Returns a list of dependents (not dependencies) of the supplied
            // dependency. This is the data structure needed for an efficient
            // topological sort.
            const getOutgoingEdges = (dependency) => pertaining.filter((dependent) => dependent !== dependency && dependent.dependsOn(dependency.name));
            const sorter = new TopologicalSorter(getOutgoingEdges);
            sorted = sorter.sort(pertaining);
            this.sortedBySubject.set(subject, sorted);
        }
        return sorted;
    }
    /**
     * Only add dependencies which can be resolved in the first place. If there
     * is a problem finding them, just skip them; they don't pertain!
     */
    add(name) {
        const modulePath = this.resolve(name);
        if (modulePath) {
            const dependency = new ExplicitDependency(modulePath);
            this.dependencies.push(dependency);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXhwbGljaXREZXBlbmRlbmN5U2V0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL0V4cGxpY2l0RGVwZW5kZW5jeVNldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLGtCQUFrQixNQUFNLHNCQUFzQixDQUFDO0FBRXRELE9BQU8saUJBQWlCLE1BQU0scUJBQXFCLENBQUM7QUFFcEQ7O0dBRUc7QUFDSCxNQUFNLENBQUMsT0FBTyxPQUFPLHFCQUFxQjtJQVV4QyxZQUFZLE9BQWlCLEVBQUUsS0FBZTtRQUM1QyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7UUFDakMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLFVBQVUsQ0FBQyxPQUFlO1FBQy9CLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxNQUFNLFVBQVUsR0FBeUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQy9ELENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUM3QyxDQUFDO1lBQ0Ysa0VBQWtFO1lBQ2xFLGlFQUFpRTtZQUNqRSxvQkFBb0I7WUFDcEIsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLFVBQThCLEVBQUUsRUFBRSxDQUMxRCxVQUFVLENBQUMsTUFBTSxDQUNmLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FDWixTQUFTLEtBQUssVUFBVSxJQUFJLFNBQVMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUNuRSxDQUFDO1lBQ0osTUFBTSxNQUFNLEdBQUcsSUFBSSxpQkFBaUIsQ0FDbEMsZ0JBQWdCLENBQ2pCLENBQUM7WUFDRixNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNqQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDM0M7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssR0FBRyxDQUFDLElBQVk7UUFDdEIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0QyxJQUFJLFVBQVUsRUFBRTtZQUNkLE1BQU0sVUFBVSxHQUFHLElBQUksa0JBQWtCLENBQUMsVUFBVSxDQUFDLENBQUM7WUFDdEQsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDcEM7SUFDSCxDQUFDO0NBQ0YifQ==